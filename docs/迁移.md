下面是基于我们之前讨论的、针对你当前代码库（Unity C#）到 Godot 的最新、可执行迁移指南。目标是保留现有语义、提高可维护性并优化热路径（Context 池化、FragTree 索引、集中调度）。按阶段、优先级、检验点和最小示例给出具体动作。
要点总结（一句话）
•	采用 Data(Resource) / State(RefCounted) / Systems(被动、由 GameLoop 调度) / FSM（每 Token/Act 一个实例）；先做小步迁移并用 Profiler 验证每一步效果。
迁移阶段一览（优先级从高到低）
1.	预备与分析（必做）
2.	框架骨架（GameLoop、Context、被动 Systems）
3.	Data 层迁移（Test/Rule/Act/Fragment → Resource）
4.	规则执行器 & FSM（TestEvaluator / RuleSystem / ActStateMachine）
5.	热路径优化（Context 池化、FragTree 索引、List 重用）
6.	验证、回归与切换
阶段 1 — 预备与分析（1 日）
•	在 Unity 用 Profiler 标出热点：Context 分配、FragTree.Count/FindAll、Rule/Test 调用数。记录典型场景数据（卡牌数量、规则条数）。
•	列出所有 ScriptableObject（Act/Rule/Test/Card/Fragment/Deck/Slot）字段清单（为导出做准备）。
•	建分支：migration/godot。
阶段 2 — 架构骨架（1–3 天） 目标：在 Godot 搭起最小可运行的框架（GameLoop + Context + 被动系统），不改原逻辑调用点（逐步替换）。 动作：
•	在 Godot 建 GameLoop.gd 并注册为 AutoLoad（负责 fixed-step 调度）。
•	实现 Context.gd（RefCounted）并加入 acquire_from_act_logic / acquire_from_context / release / dispose 池化接口。
•	实现 BehaviorSystem.gd/RuleSystem.gd/TestEvaluator.gd 为 RefCounted（被动），由 GameLoop new() 并持有。
示例签名（粘到项目）：

extends RefCounted
class_name Context

static func acquire_from_act_logic(act_logic, keep_matches := false) -> Context: pass
func release() -> void: pass
func dispose() -> void: pass


阶段 5 — 热路径优化（关键，几天到一两周） 目标：消除每帧分配与线性扫描，确保 Count/FindAll 快。 动作（优先级高→低）：
1.	Context 池化：把所有 new Context(...) 改为 Context.acquire_*(...)，并在 dispose/release 时清理但重用内部集合。
2.	把 context.matches = context.matches.GetRange(0, right) 替换为复用方式（RemoveRange 或 RemoveAt 循环）或使用共享缓冲避免分配。
3.	FragTree 索引化：
•	在 FragTree 维护 _counts: Dictionary<Fragment, int> 和 _aspect_index: Dictionary<Aspect, List<CardViz>>（增量更新）。
•	改写 Count(fragment, only_free) 和 FindAll(fragment) 使用索引（O(1)/O(k)），在 Add/Remove 更新索引。
4.	把 ModifierEvaluate -> Command（池化命令）模式引入：ActModifier/CardModifier 评估成 IModifierCommand（池化对象），Context 收集命令，dispose 时统一执行并回收。这样大幅减少临时 allocations（我已在之前示例给出 C# 版本）。
5.	若极端性能需求：把 FragTree 索引或最热循环移到 C#（Godot Mono）仅在 profiler 证明必要时。


func build_indexes():
	_counts.clear()
	_aspect_index.clear()
	for frag in fragments_res: _counts[frag] = (_counts.get(frag,0)+1)
	for cv in cards: for a in cv.frag_tree.find_all_aspects(): _aspect_index[a].append(cv)
	
	
阶段 6 — 验证、回归、切换（必做）
•	为每个迁移小步写回归测试（规则结果、slots opens、Act flows）。
•	在迁移后与 Unity 参考场景做行为比对（日志/trace 模式）。
•	用 Godot Profiler 验证 GC 分配与帧时间；重点看 Gen0 allocations、Count/FindAll 调用耗时、Context 池使用率。
•	若一切通过，切换主分支并归档旧 Unity 项目。
实务 checklist（立即可用）
•	[ ] 在 Godot 建 GameLoop.gd 并 AutoLoad。
•	[ ] 实现并使用 Context.gd 池化（替换 new Context(...)）。
•	[ ] 实现 TestEvaluator.gd 与 RuleSystem.gd（canFail 使用临时 Context 策略）。
•	[ ] 实现 ActStateMachine.gd 并替换 ActLogic.RunAct 调用。
•	[ ] 把 FragTree 改为增量索引：counts + aspect->card list。
•	[ ] 用对象池实现 Modifier → Command（Pooled commands），Context 收集并在 dispose 时执行并回收。
•	[ ] 把 BehaviorSystem 作为 RefCounted 由 GameLoop new() 并在 fixed-step 调用，handlers 拆文件。
•	[ ] 集中 RNG（GameLoop 或 BehaviorSystem 提供 set_seed）。
验证场景（快速测试）
•	创建一个小场景（10~100 卡牌）并比较 Unity 与 Godot 执行结果（ActAttempt、Slot Opens、spawn）。
•	运行 profiler：确保 Context 分配显著下降、Count/FindAll 调用时间下降。
常见陷阱与解决
•	canFail 副作用：若你希望旧行为保留（可选测试会修改 matches），明确记录并决定采用哪种语义；推荐“不污染主 Context”。
•	资源映射：Unity asset 引用需映射到 Godot paths；自动导入脚本中保持 name/guid 对照表。
•	Timer 语义差异：Unity 使用 coroutine/Invoke，请用 GameLoop 固定步或 SceneTreeTimer 明确时间。
下一步我可以直接帮你（选一项）：
•	A) 生成 Context.gd（完整实现含池化、Acquire/Release、Dispose 执行命令）补丁；
•	B) 生成 RuleSystem.gd + TestEvaluator.gd 的完整 Godot 脚本（含 canFail 临时 Context 策略）；
•	C) 生成 FragTree.gd 的索引化实现（build_indexes/count/find_all）补丁；
•	D) 生成 C# 版的 Modifier → PooledCommand 模式补丁（把 Rule.Execute 改为使用 ModifierEvaluator 与 pooled commands）。
你想先要哪一个？
